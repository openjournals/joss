<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">2809</article-id>
<article-id pub-id-type="doi">10.21105/joss.02809</article-id>
<title-group>
<article-title>dymos: A Python package for optimal control of
multidisciplinary systems</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0001-9864-4928</contrib-id>
<string-name>Robert Falck</string-name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0002-7506-7360</contrib-id>
<string-name>Justin S. Gray</string-name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<string-name>Kaushik Ponnapalli</string-name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<string-name>Ted Wright</string-name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>NASA Glenn Research Center</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>HX5 LLC</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2021-03-23">
<day>23</day>
<month>3</month>
<year>2021</year>
</pub-date>
<volume>6</volume>
<issue>59</issue>
<fpage>2809</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2021</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>OpenMDAO</kwd>
<kwd>optimal control</kwd>
<kwd>trajectory optimization</kwd>
<kwd>multidisciplinary optimization</kwd>
<kwd>NASA</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Dymos is a library for optimizing control schedules for dynamic
  systems — sometimes referred to as optimal control or trajectory
  optimization. There are a number of other optimal control libraries
  that tackle similar kinds of problems, such as OTIS4
  (<xref alt="Paris et al., 2006" rid="ref-Paris2006" ref-type="bibr">Paris
  et al., 2006</xref>), GPOPS-II
  (<xref alt="Patterson &amp; Rao, 2014" rid="ref-Patterson2014GPOPSII" ref-type="bibr">Patterson
  &amp; Rao, 2014</xref>),and CASADI
  (<xref alt="Andersson et al., 2019" rid="ref-Andersson2018" ref-type="bibr">Andersson
  et al., 2019</xref>). These tools all rely on gradient-based
  optimization to solve optimal control problems, though their methods
  of computing the gradients vary. Dymos is built on top of the OpenMDAO
  framework
  (<xref alt="Gray et al., 2019" rid="ref-Gray2019a" ref-type="bibr">Gray
  et al., 2019</xref>) and supports its modular derivative system which
  allows users to mix-and-match from finite-differencing, complex-step,
  hand-differentiated, and algorithmic differentiation. This flexibility
  allows Dymos to efficiently solve optimal control problems constructed
  with both ordinary differential equations (ODE) and
  differential-algebraic equations (DAE).</p>
  <p>Dymos can also help solve more general optimization problems where
  dynamics are only one part in a larger system-level model with
  additional — potentially computationally expensive — calculations that
  come before and after the dynamic calculations. These broader problems
  are commonly referred to as co-design, controls-co-design, and
  multidisciplinary design optimization. Dymos provides specific APIs
  and features that make it possible to integrate traditional
  optimal-control models into a co-design context, while still
  supporting analytic derivatives that are necessary for computational
  efficiency in these complex use cases. An example of a co-design
  problem that was solved with Dymos is the coupled trajectory-thermal
  design of an electric vertical takeoff and landing aircraft where the
  thermal management and propulsion systems were designed simultaneously
  with the flight trajectories to ensure no components overheated
  (<xref alt="Hendricks et al., 2020" rid="ref-Hariton2020a" ref-type="bibr">Hendricks
  et al., 2020</xref>).</p>
</sec>
<sec id="difference-between-optimal-control-and-co-design">
  <title>Difference between optimal-control and co-design</title>
  <p>Optimal-control and co-design problems deal with dynamic systems.
  The evolution of the states over time is governed by an ordinary
  differential equation (ODE) or differential-algebraic equation (DAE):
  Here, <inline-formula><alternatives>
  <tex-math><![CDATA[\bar{x}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
  is a vector of time-varying state variables whose behavior is affected
  by time (<inline-formula><alternatives>
  <tex-math><![CDATA[t]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>t</mml:mi></mml:math></alternatives></inline-formula>),
  a vector of dynamic controls (<inline-formula><alternatives>
  <tex-math><![CDATA[\bar{u}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>),
  and a vector of static design parameters
  (<inline-formula><alternatives>
  <tex-math><![CDATA[\bar{d}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>d</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>).</p>
  <p>To optimize a dynamic system we also need to account for the
  objective function (<inline-formula><alternatives>
  <tex-math><![CDATA[J]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>J</mml:mi></mml:math></alternatives></inline-formula>):
  In addition, there are constraints that typically need to be enforced:
  </p>
  <p>In the mathematical sense what distinguishes optimal control from
  co-design is the particulars of which design variables and constraints
  are actually considered by the optimization. Pure optimal-control
  problems deal with a system of fixed design and seek to maximize
  performance by adjusting dynamic quantities
  (<inline-formula><alternatives>
  <tex-math><![CDATA[t, \bar{x}, \bar{u}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>)
  such as position, speed, fuel-burned, and battery state-of-charge.
  Co-design problems simultaneously vary the static design parameters of
  a system (<inline-formula><alternatives>
  <tex-math><![CDATA[\bar{d}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>d</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>)
  and its dynamic behavior (<inline-formula><alternatives>
  <tex-math><![CDATA[t, \bar{x}, \bar{u}]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>)
  to reach maximum performance.</p>
  <p>In practice, the mathematical distinction is too rigid and a more
  practical distinction is made based on where the static and dynamic
  calculations are implemented and how complex each of them is. For very
  simple physical design parameters (e.g. the radius of a cannon ball,
  spring constants, linkage lengths, etc) it is common to integrate the
  design calculations directly into the ODE. Even though the
  calculations are static in nature, they can easily be coded as part of
  the ODE and still fit well into the optimal-control paradigm. The
  optimization structure thus looks like this:</p>
  <fig>
    <caption><p>Model structure for a traditional optimal control
    problem</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="flow_charts/opt_control.png" xlink:title="" />
  </fig>
  <p>However, not all problems can be handled with such a compact
  implementation. For example if the physical design problem included
  shaping of an airfoil using expensive numerical solutions of partial
  differential equations (PDE) to predict drag, then one would not want
  to embed that PDE solver into the dynamic model. Instead the user
  could set up a coupled model with the PDE solver going first, and
  passing a table of data to be interpolated to the dynamic model. This
  effectively splits calculations up into static and dynamic components.
  This implementation structure is called co-design.</p>
  <p>Traditionally, this co-design implementation would be done via
  sequential optimization with a manual outer design iteration between
  the static and dynamic models, potentially with different teams of
  people working on each one. One team would come up with a physical
  design using their own internal optimization setup. A second team
  takes the design and generates optimal-control profiles for it. Of
  course, the iterations do not need to be manual. It is also possible
  to set up an iterative loop around static and dynamic models to
  converge the problem numerically. A sequential co-design
  implementation looks like this:</p>
  <fig>
    <caption><p>Model structure for a sequential co-design
    problem</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="flow_charts/sequential_co_design.png" xlink:title="" />
  </fig>
  <p>Dymos can support sequential co-design, but its unique value is
  that it also enables a more tightly-coupled co-design process with a
  single top level optimizer handling both parts of the problem
  simultaneously.</p>
  <fig>
    <caption><p>Model structure for a coupled co-design
    problem</p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="flow_charts/coupled_co_design.png" xlink:title="" />
  </fig>
  <p>Compared to sequential co-design, coupled co-design offers the
  potential to find better designs with much lower computational cost.
  However, it is also more challenging to implement because the
  top-level optimizer requires derivatives to be propagated between the
  static and dynamic parts of the model. Dymos overcomes this difficulty
  by providing APIs to exploit OpenMDAO’s analytic derivative
  functionality at the model level. Data can be passed from the static
  model to the dynamic model and vice versa, allowing the construction
  of the coupled model for optimization.</p>
</sec>
<sec id="ode-versus-dae">
  <title>ODE versus DAE</title>
  <p>Optimal-control software typically requires that the dynamics of
  the system be defined as a set of ordinary differential equations
  (ODE) that use explicit functions to compute the rates of the state
  variables to be time-integrated. Sometimes the dynamics are instead
  posed as a set of differential-algebraic equations (DAE), where some
  residual equations need to be satisfied implicitly in order to solve
  for the state rates. From the perspective of an optimal-control or
  co-design problem both ODE and DAE formulations provide state rates
  that need to be integrated over time. The difference is that ODEs are
  explicit functions which are relatively easy to differentiate, but
  DAEs are implicit functions which are much more difficult to
  differentiate. Since the derivatives are needed to perform
  optimization, DAEs are more challenging to optimize.</p>
  <p>One relatively common use case for DAEs is differential inclusions,
  in which the state trajectory is posed as a dynamic control and the
  traditional control schedule needed to achieve that trajectory is
  found using a nonlinear solver within the dynamic model
  (<xref alt="Seywald, 1994" rid="ref-Seywald1994" ref-type="bibr">Seywald,
  1994</xref>). For some problems this method provides a more natural
  and numerically-beneficial design space for the optimizer to traverse,
  but the nonlinear solver poses numerical challenges for computing
  derivatives for the optimizer. A simple approach to this is to just
  use finite-differences across the nonlinear solver, but this has been
  shown to be expensive and numerically unstable
  (<xref alt="Gray et al., 2014" rid="ref-gray2014derivatives" ref-type="bibr">Gray
  et al., 2014</xref>). Another option, taken by some optimal control
  libraries, is to apply monolithic algorithmic differentiation
  (<xref alt="Griewank, 2003" rid="ref-griewank2003mathematical" ref-type="bibr">Griewank,
  2003</xref>) across the nonlinear solver. While it does provide
  accurate derivatives, the monolithic approach is expensive and uses a
  lot of memory
  (<xref alt="Kenway et al., 2019" rid="ref-kenway2019effective" ref-type="bibr">Kenway
  et al., 2019</xref>;
  <xref alt="Mader et al., 2008" rid="ref-mader2008adjoint" ref-type="bibr">Mader
  et al., 2008</xref>). The most efficient approach is to use a pair of
  analytic derivative approaches called the direct and adjoint methods,
  which were generalized in a single unified derivative equation (UDE)
  by Hwang and Martins
  (<xref alt="Hwang &amp; Martins, 2018" rid="ref-hwang2018b" ref-type="bibr">Hwang
  &amp; Martins, 2018</xref>).</p>
  <p>Dymos adopts the UDE approach, which uses a linear solver to
  compute total derivatives needed by the optimizer using only partial
  derivatives of the residual equations in the DAE. This approach offers
  two key advantages. First, partial derivatives of the DAE residual
  equations are much less computationally challenging to compute.
  Second, by using the OpenMDAO underpinnings of Dymos, users can
  construct their DAE in a modular fashion and combine various methods
  of computing the partial derivatives via finite-difference,
  complex-step
  (<xref alt="Martins et al., 2003" rid="ref-Martins2003CS" ref-type="bibr">Martins
  et al., 2003</xref>), algorithmic differentiation, or hand
  differentiation as needed.</p>
  <sec id="the-dymos-perspective-on-optimal-control">
    <title>The Dymos perspective on optimal control</title>
    <p>Dymos breaks the trajectory into portions of time called
    <italic>phases</italic>. Breaking the trajectory into phases
    provides several capabilities. Intermediate constraints along a
    trajectory can be enforced by applying a boundary constraint to a
    phase that begins or ends at the time of interest. For instance, the
    optimal trajectory of a launch vehicle may be required to ascend
    vertically to clear a launch tower before it pitches over on its way
    to orbit. Path constraints can be applied within each phase to bound
    some performance parameter within that phase. For example, reentry
    vehicles may need to adjust their trajectory to limit aerodynamic
    heating.</p>
    <p>Each phase in a trajectory can use its own separate ODE. For
    instance, an aircraft with vertical takeoff and landing capability
    may use different ODEs for vertical flight and horizontal flight.
    ODEs are implemented as standard OpenMDAO models which are passed to
    phases at instantiation time with some additional annotations to
    identify the states, state-rates, and control inputs.</p>
    <p>Every phase uses its own specific time discretization tailored to
    the dynamics in that portion of the trajectory. If one part of a
    trajectory has fast dynamics and another has slow dynamics, the time
    evolution can be broken into two phases with separate time
    discretizations.</p>
    <p>In the optimal-control community there are a number of different
    techniques for discretizing the continuous optimal control problem
    into a form that can be solved by a nonlinear optimization
    algorithm; each one is called a transcription. Dymos supports two
    different collocation transcriptions: high-order Gauss-Lobatto
    (<xref alt="Herman &amp; Conway, 1996" rid="ref-Herman1996" ref-type="bibr">Herman
    &amp; Conway, 1996</xref>) and Radau
    (<xref alt="Garg et al., 2009" rid="ref-Garg2009" ref-type="bibr">Garg
    et al., 2009</xref>). Both of these represent state and control
    trajectories as piece-wise polynomials of at least 3rd order and are
    formulated in a way that makes it possible to efficiently compute
    the needed quantities to perform integration in a numerically
    rigorous fashion.</p>
    <p>Dymos also allows the user to choose whether the optimization
    problem is solved using an explicit or implicit approach. Some
    caution with terminology must be taken here because the term
    “implicit” is often used to describe time integration schemes
    (e.g. backwards Euler), but that is not what is meant in an
    optimal-control context. Here, explicit propagation is one where the
    full state trajectory is computed starting from the initial value
    and propagating forward or from the final value and propagating
    backward. From the optimizer’s perspective it will set values for
    the initial or final state (<inline-formula><alternatives>
    <tex-math><![CDATA[\bar{x}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>),
    the design parameters (<inline-formula><alternatives>
    <tex-math><![CDATA[\bar{d}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>d</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>),
    and the controls (<inline-formula><alternatives>
    <tex-math><![CDATA[\bar{u}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>)
    and can expect to be given a physically valid time evolution of the
    states as the output. Wrapping an optimizer around an explicit
    propagation gives what is traditionally called a “shooting method”
    in the optimal-control world. In contrast, implicit propagation used
    within an optimization does not provide valid trajectories on its
    own. Instead, implicit methods add a discretized time-evolution of
    the state vector (<inline-formula><alternatives>
    <tex-math><![CDATA[\bar{x}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>x</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover></mml:math></alternatives></inline-formula>)
    as an additional design variable to the optimizer and add an
    associated set of defect constraints that must be driven to zero to
    enforce physics at some set of discrete points in time where the ODE
    is evaluated. The net effect is that the full state trajectory is
    only known once the optimization is fully converged. In the context
    of the multidisciplinary design optimization field, explicit phases
    are similar to the multidisciplinary design feasible (MDF)
    optimization architecture and implicit phases are similar to the
    simultaneous analysis and design (SAND) optimization architecture
    (<xref alt="Martins &amp; Lambe, 2013" rid="ref-Martins2013" ref-type="bibr">Martins
    &amp; Lambe, 2013</xref>).</p>
    <p>Both implicit and explicit phases are useful in different
    circumstances. Explicit propagation can seem to many like a more
    natural way to formulate the problem because it matches the way one
    would use time integration without optimization. However, when used
    with optimization explicit propagation is more computationally
    expensive, sensitive to singularities in the ODE, and potentially
    unable to converge to a valid solution. Implicit propagation tends
    to be less intuitive computationally, since it does not provide
    valid state histories without a converged optimization. The
    advantages of implicit propagation are that it tends to be faster,
    more numerically stable, and more scalable — though also highly
    sensitive to initial conditions and optimization scaling.</p>
    <p>Dymos supports both explicit and implicit propagation for both
    its transcriptions, and even allows mixtures of implicitly and
    explicitly propagated states within a phase. This flexibility is
    valuable because it allows users to tailor their optimization to
    suit their needs. Switching transcriptions and changing from
    implicit to explicit requires very minor code changes — typically a
    single line in the run-script. Examples of how to swap between them
    are given in the code sample below.</p>
  </sec>
</sec>
<sec id="choice-of-optimization-algorithm">
  <title>Choice of optimization algorithm</title>
  <p>Dymos is not distributed with an optimizer, but relies on the
  optimizers that are available in the OpenMDAO installation. OpenMDAO
  ships with an interface to the optimizers in SciPy
  (<xref alt="Virtanen et al., 2020" rid="ref-2020SciPy-NMeth" ref-type="bibr">Virtanen
  et al., 2020</xref>), and an additional wrapper for the pyoptsparse
  library
  (<xref alt="Wu et al., 2020" rid="ref-Wu_pyoptsparse_2020" ref-type="bibr">Wu
  et al., 2020</xref>) which has more powerful optimizer options such as
  SNOPT
  (<xref alt="Gill et al., 2005" rid="ref-GilMS05" ref-type="bibr">Gill
  et al., 2005</xref>) and IPOPT
  (<xref alt="Wächter &amp; Biegler, 2006" rid="ref-wachter2006" ref-type="bibr">Wächter
  &amp; Biegler, 2006</xref>). OpenMDAO also allows users to integrate
  their own optimizer of choice, which Dymos can then seamlessly use
  with without any additional modifications. For simple problems,
  Scipy’s SLSQP optimizer generally works fine. On more challenging
  optimal-control problems higher-quality optimizers are important for
  getting good performance.</p>
  <p>Though one could technically choose any optimization algorithm,
  Dymos is designed to work primarily with gradient-based algorithms. In
  general, optimal-control and co-design problems will have both a very
  large number of design variables and a very large number of
  constraints. Both of these issues make gradient-based methods the
  strongly-preferred choice. Gradient-free methods could potentially be
  used in certain narrow circumstances with problems built using purely
  explicit phases and set up intentionally to have a small set of design
  variables and constraints.</p>
  <sec id="statement-of-need">
    <title>Statement of Need</title>
    <p>When dealing with the design of complex systems that include
    transient behavior, co-design becomes critical
    (<xref alt="Garcia-Sanz, 2019" rid="ref-garciasans2019" ref-type="bibr">Garcia-Sanz,
    2019</xref>). Broadly there are two approaches: sequential co-design
    or coupled co-design
    (<xref alt="Fathy et al., 2001" rid="ref-Fathy2001" ref-type="bibr">Fathy
    et al., 2001</xref>;
    <xref alt="Peters et al., 2009" rid="ref-Peters2009" ref-type="bibr">Peters
    et al., 2009</xref>). The best choice depends on the degree of
    interaction, or coupling, between various sub-systems. If the
    coupling is strong a coupled co-design approach is necessary to
    achieve the best performance.</p>
    <p>Though there are a number of effective optimal-control libraries,
    they tend to assume that they are on top of the modeling stack. They
    frame every optimization problem as if it were a pure
    optimal-control problem, and hence are best suited to be used in a
    sequential co-design style. This poses large challenges when
    expanding to tightly-coupled problems, where the interactions
    between the static and dynamic systems are very strong.</p>
    <p>Dymos provides a set of unique capabilities that make coupled
    co-design possible via efficient gradient-based optimization
    methods. It provides differentiated time-integration schemes that
    can generate transient models from user provided ODEs, along with
    APIs that enable users to couple these transient models with other
    models to form the co-design system while carrying the
    differentiation through that coupling. It also supports efficient
    differentiation of DAEs that include implicit relationships, which
    allows for a much broader set of possible ways to pose transient
    models. These two features combined make Dymos capable of handling
    coupled co-design problems in a manner that is more efficient than a
    pure optimal-control approach.</p>
  </sec>
  <sec id="selected-applications-of-dymos">
    <title>Selected applications of Dymos</title>
    <p>Dymos has been used to demonstrate the coupling of flight
    dynamics and subsystem thermal constraints in electrical aircraft
    applications
    (<xref alt="Falck et al., 2017" rid="ref-Falck2017a" ref-type="bibr">Falck
    et al., 2017</xref>;
    <xref alt="Hendricks et al., 2020" rid="ref-Hariton2020a" ref-type="bibr">Hendricks
    et al., 2020</xref>). NASA’s X-57 “Maxwell” is using Dymos for
    mission planning to maximize data collection while abiding the
    limits of battery storage capacity and subsystem temperatures
    (<xref alt="Schnulo et al., 2018" rid="ref-Schnulo2018a" ref-type="bibr">Schnulo
    et al., 2018</xref>,
    <xref alt="2019" rid="ref-Schnulo2019a" ref-type="bibr">2019</xref>).
    Other authors have used Dymos to perform studies of aircraft
    acoustics
    (<xref alt="Ingraham et al., 2020" rid="ref-Ingraham2020a" ref-type="bibr">Ingraham
    et al., 2020</xref>) and the design of supersonic aircraft with
    thermal fuel management systems
    (<xref alt="Jasa et al., 2018" rid="ref-Jasa2018a" ref-type="bibr">Jasa
    et al., 2018</xref>).</p>
  </sec>
  <sec id="optimal-control-example-brachistochrone">
    <title>Optimal-control example: Brachistochrone</title>
    <p>As a simple use case of Dymos, consider the classic
    brachistochrone optimal-control problem. There is a bead sliding
    along a frictionless wire strung between two points of different
    heights, and we seek the shape of the wire such that the bead
    travels from start to finish in the shortest time. The time-varying
    control is the angle of the wire at each point in time and there are
    no design parameters, which makes this a pure optimal-control
    problem.</p>
    <code language="python">import numpy as np
import openmdao.api as om
import dymos as dm
import matplotlib.pyplot as plt

# First define a system which computes the equations of motion
class BrachistochroneEOM(om.ExplicitComponent):
    def initialize(self):
        self.options.declare('num_nodes', types=int)

    def setup(self):
        nn = self.options['num_nodes']

        # Inputs
        self.add_input('v', val=np.zeros(nn), units='m/s', desc='velocity')
        self.add_input('theta', val=np.zeros(nn), units='rad',
                       desc='angle of wire')
        self.add_output('xdot', val=np.zeros(nn), units='m/s',
                        desc='x rate of change')
        self.add_output('ydot', val=np.zeros(nn), units='m/s',
                        desc='y rate of change')
        self.add_output('vdot', val=np.zeros(nn), units='m/s**2',
                        desc='v rate of change')

        # Ask OpenMDAO to compute the partial derivatives using complex-step
        # with a partial coloring algorithm for improved performance
        self.declare_partials(of='*', wrt='*', method='cs')
        self.declare_coloring(wrt='*', method='cs', show_summary=True)

    def compute(self, inputs, outputs):
        v, theta = inputs.values()
        outputs['vdot'] = 9.80665 * np.cos(theta)
        outputs['xdot'] = v * np.sin(theta)
        outputs['ydot'] = -v * np.cos(theta)

p = om.Problem()

# Define a Trajectory object
traj = p.model.add_subsystem('traj', dm.Trajectory())

# Define a Dymos Phase object with GaussLobatto Transcription
tx = dm.GaussLobatto(num_segments=10, order=3)
phase = dm.Phase(ode_class=BrachistochroneEOM, transcription=tx)

traj.add_phase(name='phase0', phase=phase)

# Set the time options
phase.set_time_options(fix_initial=True,
                       duration_bounds=(0.5, 10.0))
# Set the state options
phase.add_state('x', rate_source='xdot',
                fix_initial=True, fix_final=True)
phase.add_state('y', rate_source='ydot',
                fix_initial=True, fix_final=True)
phase.add_state('v', rate_source='vdot',
                fix_initial=True, fix_final=False)
# Define theta as a control.
phase.add_control(name='theta', units='rad',
                  lower=0, upper=np.pi)
# Minimize final time.
phase.add_objective('time', loc='final')

# Set the driver.
p.driver = om.ScipyOptimizeDriver()

# Allow OpenMDAO to automatically determine total
# derivative sparsity pattern.
# This works in conjunction with partial derivative
# coloring to give a large speedup
p.driver.declare_coloring()

# Setup the problem
p.setup()

# Now that the OpenMDAO problem is setup, we can guess the
# values of time, states, and controls.
p.set_val('traj.phase0.t_duration', 2.0)

# States and controls here use a linearly interpolated
# initial guess along the trajectory.
p.set_val('traj.phase0.states:x',
          phase.interpolate(ys=[0, 10], nodes='state_input'),
          units='m')
p.set_val('traj.phase0.states:y',
          phase.interpolate(ys=[10, 5], nodes='state_input'),
          units='m')
p.set_val('traj.phase0.states:v',
          phase.interpolate(ys=[0, 5], nodes='state_input'),
          units='m/s')
# constant initial guess for control
p.set_val('traj.phase0.controls:theta', 90, units='deg')

# Run the driver to solve the problem and generate default plots of
# state and control values vs time
dm.run_problem(p, make_plots=True, simulate=True)

# Additional custom plot of y vs x to show the actual wire shape
fig, ax = plt.subplots(figsize=(6.4, 3.2))
x = p.get_val('traj.phase0.timeseries.states:x', units='m')
y = p.get_val('traj.phase0.timeseries.states:y', units='m')
ax.plot(x,y, marker='o')
ax.set_xlabel('x (m)')
ax.set_ylabel('y (m)')
fig.savefig('brachistochone_yx.png', bbox_inches='tight')</code>
    <p>The built-in plotting utility in Dymos will plot all relevant
    quantities vs time:</p>
    <p><inline-graphic mimetype="image" mime-subtype="png" xlink:href="brachistochrone_states_y.png" />
    <inline-graphic mimetype="image" mime-subtype="png" xlink:href="brachistochrone_states_x.png" /></p>
    <p>The more traditional way to view the brachistochrone solution is
    to view the actual shape of the wire (i.e. y vs x):</p>
    <fig>
      <caption><p>Brachistochrone Solution: y as a function of
      x</p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="brachistochone_yx.png" xlink:title="" />
    </fig>
  </sec>
  <sec id="coupled-co-design-example-designing-a-cannonball">
    <title>Coupled co-design example: Designing a cannonball</title>
    <p>This co-design example seeks to find the best size cannonball to
    maximize range, considering aerodynamic drag subject to a limit on
    initial kinetic energy. Given the same kinetic energy, a lighter
    ball will go faster, and hence farther, if aerodynamic drag is
    ignored. Heavier cannonballs will have more inertia to counteract
    drag. There is a balance between these two effects, which the
    optimizer seeks to find.</p>
    <p>Here the static calculations are to find the mass and frontal
    area of the cannonball, given its radius. Then the ODE takes the
    mass and area as inputs and via Dymos can compute the total range.
    For demonstration purposes the trajectory is broken up into an
    ascent and descent phase, with the break being set up exactly at the
    apogee of the flight path.</p>
    <code language="python">import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

import openmdao.api as om

import dymos as dm
from dymos.models.atmosphere.atmos_1976 import _USatm1976Data as USatm1976Data

# CREATE an atmosphere interpolant
english_to_metric_rho = om.unit_conversion('slug/ft**3', 'kg/m**3')[0]
english_to_metric_alt = om.unit_conversion('ft', 'm')[0]
rho_interp = interp1d(np.array(USatm1976Data.alt*english_to_metric_alt, dtype=complex), 
                      np.array(USatm1976Data.rho*english_to_metric_rho, dtype=complex), kind='linear')


class CannonballSize(om.ExplicitComponent):
    &quot;&quot;&quot;
    Static calculations performed before the dynamic model
    &quot;&quot;&quot;

    def setup(self):
        self.add_input(name='radius', val=1.0, 
                       desc='cannonball radius', units='m')
        self.add_input(name='density', val=7870., 
                       desc='cannonball density', units='kg/m**3')

        self.add_output(name='mass', shape=(1,), 
                       desc='cannonball mass', units='kg')
        self.add_output(name='area', shape=(1,), 
                       desc='aerodynamic reference area', units='m**2')

        self.declare_partials(of='*', wrt='*', method='cs')

    def compute(self, inputs, outputs):
        radius = inputs['radius']
        rho = inputs['density']

        outputs['mass'] = (4/3.) * rho * np.pi * radius ** 3
        outputs['area'] = np.pi * radius ** 2


class CannonballODE(om.ExplicitComponent): 
    &quot;&quot;&quot;
    Cannonball ODE assuming flat earth and accounting for air resistance
    &quot;&quot;&quot;

    def initialize(self): 
        self.options.declare('num_nodes', types=int)

    def setup(self): 
        nn = self.options['num_nodes']

        # static parameters
        self.add_input('mass', units='kg')
        self.add_input('area', units='m**2')

        # time varying inputs 
        self.add_input('alt', units='m', shape=nn)
        self.add_input('v', units='m/s', shape=nn)
        self.add_input('gam', units='rad', shape=nn)

        # state rates
        self.add_output('v_dot', shape=nn, units='m/s**2')
        self.add_output('gam_dot', shape=nn, units='rad/s')
        self.add_output('h_dot', shape=nn, units='m/s')
        self.add_output('r_dot', shape=nn, units='m/s')
        self.add_output('ke', shape=nn, units='J')

        # Ask OpenMDAO to compute the partial derivatives using complex-step 
        # with a partial coloring algorithm for improved performance
        self.declare_partials('*', '*', method='cs')
        self.declare_coloring(wrt='*', method='cs')

    def compute(self, inputs, outputs): 

        gam = inputs['gam']
        v = inputs['v']
        alt = inputs['alt']
        m = inputs['mass']
        S = inputs['area']

        CD = 0.5 # good assumption for a sphere
        GRAVITY = 9.80665 # m/s**2

        # handle complex-step gracefully from the interpolant
        if np.iscomplexobj(alt): 
            rho = rho_interp(inputs['alt'])
        else: 
            rho = rho_interp(inputs['alt']).real

        q = 0.5*rho*inputs['v']**2
        qS = q * S
        D = qS * CD
        cgam = np.cos(gam)
        sgam = np.sin(gam)
        outputs['v_dot'] = - D/m-GRAVITY*sgam
        outputs['gam_dot'] = -(GRAVITY/v)*cgam
        outputs['h_dot'] = v*sgam
        outputs['r_dot'] = v*cgam
        outputs['ke'] = 0.5*m*v**2

if __name__ == &quot;__main__&quot;: 

    p = om.Problem()

    ###################################
    # Co-design part of the model, 
    # static analysis outside of Dymos
    ###################################
    static_calcs = p.model.add_subsystem('static_calcs', CannonballSize())
    static_calcs.add_design_var('radius', lower=0.01, upper=0.10, 
                                ref0=0.01, ref=0.10)

    p.model.connect('static_calcs.mass', 'traj.parameters:mass')
    p.model.connect('static_calcs.area', 'traj.parameters:area')

    traj = p.model.add_subsystem('traj', dm.Trajectory())
    # Declare parameters that will be constant across 
    # the two phases of the trajectory, so we can connect to it only once
    traj.add_parameter('mass', units='kg', val=0.01, dynamic=False)
    traj.add_parameter('area', units='m**2', dynamic=False)

    tx = dm.Radau(num_segments=5, order=3, compressed=True)
    ascent = dm.Phase(transcription=tx, ode_class=CannonballODE)
    traj.add_phase('ascent', ascent)

    ###################################
    # first phase: ascent
    ###################################
    # All initial states except flight path angle are fixed
    ascent.add_state('r', units='m', rate_source='r_dot', 
                     fix_initial=True, fix_final=False)
    ascent.add_state('h', units='m', rate_source='h_dot', 
                     fix_initial=True, fix_final=False)
    ascent.add_state('v', units='m/s', rate_source='v_dot', 
                     fix_initial=False, fix_final=False)
    # Final flight path angle is fixed (
    #     we will set it to zero so that the phase ends at apogee)
    ascent.add_state('gam', units='rad', rate_source='gam_dot', 
                     fix_initial=False, fix_final=True)    
    ascent.set_time_options(fix_initial=True, duration_bounds=(1, 100), 
                            duration_ref=100, units='s')

    ascent.add_parameter('mass', units='kg', val=0.01, dynamic=False)
    ascent.add_parameter('area', units='m**2', dynamic=False)

    # Limit the initial muzzle energy to create a well posed problem 
    # with respect to cannonball size and initial velocity
    ascent.add_boundary_constraint('ke', loc='initial', units='J',
                                   upper=400000, lower=0, ref=100000)

    ###################################
    # second phase: descent
    ###################################
    tx = dm.GaussLobatto(num_segments=5, order=3, compressed=True)
    descent = dm.Phase(transcription=tx, ode_class=CannonballODE)
    traj.add_phase('descent', descent )

    # All initial states and time are free so their 
    #    values can be linked to the final ascent values
    # Final altitude is fixed to 0 to ensure final impact on the ground
    descent.add_state('r', units='m', rate_source='r_dot', 
                      fix_initial=False, fix_final=False)
    descent.add_state('h', units='m', rate_source='h_dot', 
                      fix_initial=False, fix_final=True)
    descent.add_state('gam', units='rad', rate_source='gam_dot', 
                      fix_initial=False, fix_final=False)
    descent.add_state('v', units='m/s', rate_source='v_dot',
                      fix_initial=False, fix_final=False)
    descent.set_time_options(initial_bounds=(.5, 100), duration_bounds=(.5, 100),
                             duration_ref=100, units='s')
    
    descent.add_parameter('mass', units='kg', val=0.01, dynamic=False)
    descent.add_parameter('area', units='m**2', dynamic=False)

    # Link Phases (link time and all state variables)
    traj.link_phases(phases=['ascent', 'descent'], vars=['*'])

    # maximize range
    descent.add_objective('r', loc='final', ref=-1.0)

    p.driver = om.pyOptSparseDriver()
    p.driver.options['optimizer'] = 'SLSQP'
    p.driver.declare_coloring()

    # Finish Problem Setup
    p.setup()

    # Set Initial guesses for static dvs and ascent
    p.set_val('static_calcs.radius', 0.05, units='m')
    p.set_val('traj.ascent.t_duration', 10.0)

    p.set_val('traj.ascent.states:r', 
              ascent.interpolate(ys=[0, 100], nodes='state_input'))
    p.set_val('traj.ascent.states:h', 
              ascent.interpolate(ys=[0, 100], nodes='state_input'))
    p.set_val('traj.ascent.states:v', 
              ascent.interpolate(ys=[200, 150], nodes='state_input'))
    p.set_val('traj.ascent.states:gam', 
              ascent.interpolate(ys=[25, 0], nodes='state_input'), units='deg')

    # more intitial guesses for descent
    p.set_val('traj.descent.t_initial', 10.0)
    p.set_val('traj.descent.t_duration', 10.0)

    p.set_val('traj.descent.states:r', 
               descent.interpolate(ys=[100, 200], nodes='state_input'))
    p.set_val('traj.descent.states:h', 
              descent.interpolate(ys=[100, 0], nodes='state_input'))
    p.set_val('traj.descent.states:v', 
              descent.interpolate(ys=[150, 200], nodes='state_input'))
    p.set_val('traj.descent.states:gam', 
              descent.interpolate(ys=[0, -45], nodes='state_input'), units='deg')

    dm.run_problem(p, simulate=True, make_plots=True)

    fig, ax = plt.subplots()
    x0 = p.get_val('traj.ascent.timeseries.states:r', units='m')
    y0 = p.get_val('traj.ascent.timeseries.states:h', units='m')
    x1 = p.get_val('traj.descent.timeseries.states:r', units='m')
    y1 = p.get_val('traj.descent.timeseries.states:h', units='m')
    tab20 = plt.cm.get_cmap('tab20').colors
    ax.plot(x0,y0, marker='o', label='ascent', color=tab20[0])
    ax.plot(x1,y1, marker='o', label='descent', color=tab20[1])
    ax.legend(loc='best')
    ax.set_xlabel('range (m)')
    ax.set_ylabel('height (m)')
    fig.savefig('cannonball_hr.png', bbox_inches='tight')</code>
    <p>The built-in plotting in Dymos will give time evolutions of all
    the time varying quantities. For example, these are the trajectories
    for the range and height:</p>
    <p><inline-graphic mimetype="image" mime-subtype="png" xlink:href="cannonball_states_h.png" />
    <inline-graphic mimetype="image" mime-subtype="png" xlink:href="cannonball_states_r.png" /></p>
    <p>A more natural way to view the solution is to consider height vs
    range:</p>
    <fig>
      <caption><p>Cannonball Solution: height vs time</p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="cannonball_hr.png" xlink:title="" />
    </fig>
    <p>The parabolic trajectory is slightly skewed due to the effect of
    air resistance slowing down the cannonball so it is moving slower
    during the descent than the ascent.</p>
  </sec>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>Dymos was developed with funding from NASA’s Transformational Tools
  and Technologies (<inline-formula><alternatives>
  <tex-math><![CDATA[T^3]]></tex-math>
  <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msup><mml:mi>T</mml:mi><mml:mn>3</mml:mn></mml:msup></mml:math></alternatives></inline-formula>)
  Project.</p>
</sec>
</body>
<back>
<ref-list>
  <ref-list>
    <ref id="ref-Martins2013">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Martins</surname><given-names>Joaquim R. R. A.</given-names></name>
          <name><surname>Lambe</surname><given-names>Andrew B.</given-names></name>
        </person-group>
        <article-title>Multidisciplinary design optimization: A survey of architectures</article-title>
        <source>AIAA Journal</source>
        <year iso-8601-date="2013-09">2013</year><month>09</month>
        <volume>51</volume>
        <issue>9</issue>
        <pub-id pub-id-type="doi">10.2514/1.J051895</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-gray2014derivatives">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
          <name><surname>Hearn</surname><given-names>Tristan A.</given-names></name>
          <name><surname>Moore</surname><given-names>Kenneth T.</given-names></name>
          <name><surname>Hwang</surname><given-names>John</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim</given-names></name>
          <name><surname>Ning</surname><given-names>Andrew</given-names></name>
        </person-group>
        <article-title>Automatic Evaluation of Multidisciplinary Derivatives Using a Graph-Based Problem Formulation in OpenMDAO</article-title>
        <source>15th AIAA/ISSMO Multidisciplinary Analysis and Optimization Conference</source>
        <publisher-name>American Institute of Aeronautics; Astronautics</publisher-name>
        <year iso-8601-date="2014">2014</year>
        <uri>http://dx.doi.org/10.2514/6.2014-2042</uri>
        <pub-id pub-id-type="doi">doi:10.2514/6.2014-2042</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Gray2019a">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
          <name><surname>Hwang</surname><given-names>John T.</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim R. R. A.</given-names></name>
          <name><surname>Moore</surname><given-names>Kenneth T.</given-names></name>
          <name><surname>Naylor</surname><given-names>Bret A.</given-names></name>
        </person-group>
        <article-title>OpenMDAO: An open-source framework for multidisciplinary design, analysis, and optimization</article-title>
        <source>Structural and Multidisciplinary Optimization</source>
        <year iso-8601-date="2019">2019</year>
        <volume>59</volume>
        <issue>4</issue>
        <pub-id pub-id-type="doi">10.1007/s00158-019-02211-z</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Herman1996">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Herman</surname><given-names>Albert L.</given-names></name>
          <name><surname>Conway</surname><given-names>Bruce A.</given-names></name>
        </person-group>
        <article-title>Direct optimization using collocation based on high-order Gauss-Lobatto quadrature rules</article-title>
        <source>Journal of Guidance, Control, and Dynamics</source>
        <year iso-8601-date="1996">1996</year>
        <volume>19</volume>
        <issue>3</issue>
        <pub-id pub-id-type="doi">10.2514/3.21662</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Garg2009">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Garg</surname><given-names>Divya</given-names></name>
          <name><surname>Patterson</surname><given-names>Michael</given-names></name>
          <name><surname>Darby</surname><given-names>Christopher</given-names></name>
          <name><surname>Francolin</surname><given-names>Camila</given-names></name>
          <name><surname>Huntington</surname><given-names>Geoffrey</given-names></name>
          <name><surname>Hager</surname><given-names>William</given-names></name>
          <name><surname>Rao</surname><given-names>Anil</given-names></name>
        </person-group>
        <article-title>Direct trajectory optimization and costate estimation of general optimal control problems using a radau pseudospectral method</article-title>
        <source>AIAA guidance, navigation, and control conference</source>
        <year iso-8601-date="2009">2009</year>
        <uri>https://arc.aiaa.org/doi/abs/10.2514/6.2009-5989</uri>
        <pub-id pub-id-type="doi">10.2514/6.2009-5989</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Seywald1994">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Seywald</surname><given-names>Hans</given-names></name>
        </person-group>
        <article-title>Trajectory optimization based on differential inclusion (revised)</article-title>
        <source>Journal of Guidance, Control, and Dynamics</source>
        <publisher-name>American Institute of Aeronautics; Astronautics</publisher-name>
        <year iso-8601-date="1994">1994</year>
        <volume>17</volume>
        <issue>3</issue>
        <pub-id pub-id-type="doi">10.2514/3.21224</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Hariton2020a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Hendricks</surname><given-names>Eric S.</given-names></name>
          <name><surname>Aretskin-Hariton</surname><given-names>Eliot D.</given-names></name>
          <name><surname>Ingraham</surname><given-names>Daniel J.</given-names></name>
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
          <name><surname>Schnulo</surname><given-names>Sydney L.</given-names></name>
          <name><surname>Chin</surname><given-names>Jeffrey C.</given-names></name>
          <name><surname>Falck</surname><given-names>Robert D.</given-names></name>
          <name><surname>Hall</surname><given-names>Dustin L.</given-names></name>
        </person-group>
        <article-title>Multidisciplinary optimization of an electric quadrotor urban air mobility aircraft</article-title>
        <source>AIAA aviation 2020 forum</source>
        <year iso-8601-date="2020">2020</year>
        <uri>https://arc.aiaa.org/doi/abs/10.2514/6.2020-3176</uri>
        <pub-id pub-id-type="doi">10.2514/6.2020-3176</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Ingraham2020a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Ingraham</surname><given-names>Daniel</given-names></name>
          <name><surname>Falck</surname><given-names>Robert</given-names></name>
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
        </person-group>
        <article-title>Blade and trajectory optimization of a propeller -driven electric aircraft with acoustic constraints</article-title>
        <source>AIAA aviation 2020 forum</source>
        <year iso-8601-date="2020">2020</year>
        <uri>https://arc.aiaa.org/doi/abs/10.2514/6.2020-3141</uri>
        <pub-id pub-id-type="doi">10.2514/6.2020-3141</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Falck2017a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Falck</surname><given-names>Robert D.</given-names></name>
          <name><surname>Chin</surname><given-names>Jeffrey C.</given-names></name>
          <name><surname>Schnulo</surname><given-names>Sydney L.</given-names></name>
          <name><surname>Burt</surname><given-names>Jonathan M.</given-names></name>
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
        </person-group>
        <article-title>Trajectory Optimization of Electric Aircraft Subject to Subsystem Thermal Constraints</article-title>
        <source>18th AIAA/ISSMO Multidisciplinary Analysis and Optimization Conference</source>
        <publisher-loc>Denver, CO</publisher-loc>
        <year iso-8601-date="2017">2017</year>
        <pub-id pub-id-type="doi">10.2514/6.2017-4002</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Schnulo2018a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Schnulo</surname><given-names>Sydney L.</given-names></name>
          <name><surname>Jeff Chin</surname><given-names>Robert D. Falck</given-names></name>
          <name><surname>Gray</surname><given-names>Justin S.</given-names></name>
          <name><surname>Papathakis</surname><given-names>Kurt V.</given-names></name>
          <name><surname>Clarke</surname><given-names>Sean C.</given-names></name>
          <name><surname>Reid</surname><given-names>Nickelle</given-names></name>
          <name><surname>Borer</surname><given-names>Nicholas K.</given-names></name>
        </person-group>
        <article-title>Development of a Multi-Segment Mission Planning Tool for SCEPTOR X-57</article-title>
        <source>2018 Multidisciplinary Analysis and Optimization Conference</source>
        <publisher-name>AIAA</publisher-name>
        <publisher-loc>Atlanta, GA</publisher-loc>
        <year iso-8601-date="2018-06">2018</year><month>06</month>
        <pub-id pub-id-type="doi">10.2514/6.2018-3738</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Schnulo2019a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Schnulo</surname><given-names>Sydney L.</given-names></name>
          <name><surname>Hall</surname><given-names>Dustin L.</given-names></name>
          <name><surname>Jeffrey C</surname><given-names>Chin</given-names></name>
        </person-group>
        <article-title>Further development and validation of NASA x-57 maxwell mission planning tool for mods III and IV</article-title>
        <source>AIAA propulsion and energy 2019 forum</source>
        <year iso-8601-date="2019">2019</year>
        <pub-id pub-id-type="doi">10.2514/6.2019-4491</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Jasa2018a">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Jasa</surname><given-names>John P.</given-names></name>
          <name><surname>Mader</surname><given-names>Charles A.</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim</given-names></name>
        </person-group>
        <article-title>Trajectory optimization of a supersonic aircraft with a thermal fuel management system</article-title>
        <source>2018 multidisciplinary analysis and optimization conference</source>
        <year iso-8601-date="2018">2018</year>
        <pub-id pub-id-type="doi">10.2514/6.2018-3884</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Wu_pyoptsparse_2020">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Wu</surname><given-names>Neil</given-names></name>
          <name><surname>Kenway</surname><given-names>Gaetan</given-names></name>
          <name><surname>Mader</surname><given-names>Charles A.</given-names></name>
          <name><surname>Jasa</surname><given-names>John</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim R. R. A.</given-names></name>
        </person-group>
        <article-title>pyOptSparse: A Python framework for large-scale constrained nonlinear optimization of sparse systems</article-title>
        <source>Journal of Open Source Software</source>
        <publisher-name>The Open Journal</publisher-name>
        <year iso-8601-date="2020">2020</year>
        <volume>5</volume>
        <issue>54</issue>
        <pub-id pub-id-type="doi">10.21105/joss.02564</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-GilMS05">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Gill</surname><given-names>Philip E.</given-names></name>
          <name><surname>Murray</surname><given-names>Walter</given-names></name>
          <name><surname>Saunders</surname><given-names>Michael A.</given-names></name>
        </person-group>
        <article-title>SNOPT: An SQP algorithm for large-scale constrained optimization</article-title>
        <source>SIAM Review</source>
        <year iso-8601-date="2005">2005</year>
        <volume>47</volume>
        <pub-id pub-id-type="doi">10.1137/S0036144504446096</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-wachter2006">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Wächter</surname><given-names>Andreas</given-names></name>
          <name><surname>Biegler</surname><given-names>Lorenz T.</given-names></name>
        </person-group>
        <article-title>On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming</article-title>
        <source>Mathematical Programming</source>
        <publisher-name>Springer-Verlag</publisher-name>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <year iso-8601-date="2006-03">2006</year><month>03</month>
        <volume>106</volume>
        <issue>1</issue>
        <issn>0025-5610</issn>
        <pub-id pub-id-type="doi">10.1007/s10107-004-0559-y</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-2020SciPy-NMeth">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Virtanen</surname><given-names>Pauli</given-names></name>
          <name><surname>Gommers</surname><given-names>Ralf</given-names></name>
          <name><surname>Oliphant</surname><given-names>Travis E.</given-names></name>
          <name><surname>Haberland</surname><given-names>Matt</given-names></name>
          <name><surname>Reddy</surname><given-names>Tyler</given-names></name>
          <name><surname>Cournapeau</surname><given-names>David</given-names></name>
          <name><surname>Burovski</surname><given-names>Evgeni</given-names></name>
          <name><surname>Peterson</surname><given-names>Pearu</given-names></name>
          <name><surname>Weckesser</surname><given-names>Warren</given-names></name>
          <name><surname>Bright</surname><given-names>Jonathan</given-names></name>
          <name><surname>van der Walt</surname><given-names>Stéfan J.</given-names></name>
          <name><surname>Brett</surname><given-names>Matthew</given-names></name>
          <name><surname>Wilson</surname><given-names>Joshua</given-names></name>
          <name><surname>Jarrod Millman</surname><given-names>K.</given-names></name>
          <name><surname>Mayorov</surname><given-names>Nikolay</given-names></name>
          <name><surname>Nelson</surname><given-names>Andrew R. J.</given-names></name>
          <name><surname>Jones</surname><given-names>Eric</given-names></name>
          <name><surname>Kern</surname><given-names>Robert</given-names></name>
          <name><surname>Larson</surname><given-names>Eric</given-names></name>
          <name><surname>Carey</surname><given-names>CJ</given-names></name>
          <name><surname>Polat</surname><given-names>İlhan</given-names></name>
          <name><surname>Feng</surname><given-names>Yu</given-names></name>
          <name><surname>Moore</surname><given-names>Eric W.</given-names></name>
          <name><surname>Vand erPlas</surname><given-names>Jake</given-names></name>
          <name><surname>Laxalde</surname><given-names>Denis</given-names></name>
          <name><surname>Perktold</surname><given-names>Josef</given-names></name>
          <name><surname>Cimrman</surname><given-names>Robert</given-names></name>
          <name><surname>Henriksen</surname><given-names>Ian</given-names></name>
          <name><surname>Quintero</surname><given-names>E. A.</given-names></name>
          <name><surname>Harris</surname><given-names>Charles R</given-names></name>
          <name><surname>Archibald</surname><given-names>Anne M.</given-names></name>
          <name><surname>Ribeiro</surname><given-names>Antônio H.</given-names></name>
          <name><surname>Pedregosa</surname><given-names>Fabian</given-names></name>
          <name><surname>van Mulbregt</surname><given-names>Paul</given-names></name>
          <name><surname>Contributors</surname><given-names>SciPy 1. 0</given-names></name>
        </person-group>
        <article-title>SciPy 1.0: Fundamental Algorithms for Scientific Computing in Python</article-title>
        <source>Nature Methods</source>
        <year iso-8601-date="2020">2020</year>
        <volume>17</volume>
        <pub-id pub-id-type="doi">10.1038/s41592-019-0686-2</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Andersson2018">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Andersson</surname><given-names>Joel A E</given-names></name>
          <name><surname>Gillis</surname><given-names>Joris</given-names></name>
          <name><surname>Horn</surname><given-names>Greg</given-names></name>
          <name><surname>Rawlings</surname><given-names>James B</given-names></name>
          <name><surname>Diehl</surname><given-names>Moritz</given-names></name>
        </person-group>
        <article-title>CasADi – A software framework for nonlinear optimization and optimal control</article-title>
        <source>Mathematical Programming Computation</source>
        <year iso-8601-date="2019">2019</year>
        <volume>11</volume>
        <pub-id pub-id-type="doi">10.1007/s12532-018-0139-4</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Patterson2014GPOPSII">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Patterson</surname><given-names>Michael A.</given-names></name>
          <name><surname>Rao</surname><given-names>Anil V.</given-names></name>
        </person-group>
        <article-title>GPOPS-II: A MATLAB software for solving multiple-phase optimal control problems using hp-adaptive gaussian quadrature collocation methods and sparse nonlinear programming</article-title>
        <source>ACM Transactions on Mathematical Software</source>
        <year iso-8601-date="2014">2014</year>
        <volume>41</volume>
        <issue>1</issue>
        <issn>0098-3500</issn>
        <pub-id pub-id-type="doi">10.1145/2558904</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Paris2006">
      <element-citation publication-type="chapter">
        <person-group person-group-type="author">
          <name><surname>Paris</surname><given-names>Stephen</given-names></name>
          <name><surname>Riehl</surname><given-names>John</given-names></name>
          <name><surname>Sjauw</surname><given-names>Waldy</given-names></name>
        </person-group>
        <article-title>Enhanced procedures for direct trajectory optimization using nonlinear programming and implicit integration</article-title>
        <source>AIAA/AAS astrodynamics specialist conference and exhibit</source>
        <year iso-8601-date="2006">2006</year>
        <pub-id pub-id-type="doi">10.2514/6.2006-6309</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Martins2003CS">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Martins</surname><given-names>Joaquim R. R. A.</given-names></name>
          <name><surname>Sturdza</surname><given-names>Peter</given-names></name>
          <name><surname>Alonso</surname><given-names>Juan J.</given-names></name>
        </person-group>
        <article-title>The complex-step derivative approximation</article-title>
        <source>ACM Transactions on Mathematical Software</source>
        <year iso-8601-date="2003">2003</year>
        <volume>29</volume>
        <issue>3</issue>
        <pub-id pub-id-type="doi">10.1145/838250.838251</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-griewank2003mathematical">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Griewank</surname><given-names>Andreas</given-names></name>
        </person-group>
        <article-title>A mathematical view of automatic differentiation</article-title>
        <source>Acta Numerica</source>
        <year iso-8601-date="2003">2003</year>
        <volume>12</volume>
        <issue>1</issue>
        <pub-id pub-id-type="doi">10.1017/S0962492902000132</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-mader2008adjoint">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Mader</surname><given-names>Charles A</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim RRA</given-names></name>
          <name><surname>Alonso</surname><given-names>Juan J</given-names></name>
          <name><surname>Van Der Weide</surname><given-names>Edwin</given-names></name>
        </person-group>
        <article-title>ADjoint: An approach for the rapid development of discrete adjoint solvers</article-title>
        <source>AIAA journal</source>
        <year iso-8601-date="2008">2008</year>
        <volume>46</volume>
        <issue>4</issue>
        <pub-id pub-id-type="doi">doi:10.2514/1.29123</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-kenway2019effective">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Kenway</surname><given-names>Gaetan KW</given-names></name>
          <name><surname>Mader</surname><given-names>Charles A</given-names></name>
          <name><surname>He</surname><given-names>Ping</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim RRA</given-names></name>
        </person-group>
        <article-title>Effective adjoint approaches for computational fluid dynamics</article-title>
        <source>Progress in Aerospace Sciences</source>
        <publisher-name>Elsevier</publisher-name>
        <year iso-8601-date="2019">2019</year>
        <volume>110</volume>
        <pub-id pub-id-type="doi">10.1016/j.paerosci.2019.05.002</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-garciasans2019">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Garcia-Sanz</surname><given-names>Mario</given-names></name>
        </person-group>
        <article-title>Control co-design: An engineering game changer</article-title>
        <source>Advanced Control for Applications</source>
        <year iso-8601-date="2019">2019</year>
        <volume>1</volume>
        <issue>1</issue>
        <pub-id pub-id-type="doi">10.1002/adc2.18</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Fathy2001">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Fathy</surname><given-names>H. K.</given-names></name>
          <name><surname>Reyer</surname><given-names>J. A.</given-names></name>
          <name><surname>Papalambros</surname><given-names>P. Y.</given-names></name>
          <name><surname>Ulsov</surname><given-names>A. G.</given-names></name>
        </person-group>
        <article-title>On the coupling between the plant and controller optimization problems</article-title>
        <source>Proceedings of the 2001 american control conference.</source>
        <year iso-8601-date="2001">2001</year>
        <pub-id pub-id-type="doi">10.1109/ACC.2001.946008</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Peters2009">
      <element-citation publication-type="paper-conference">
        <person-group person-group-type="author">
          <name><surname>Peters</surname><given-names>Diane L.</given-names></name>
          <name><surname>Papalambros</surname><given-names>Panos Y.</given-names></name>
          <name><surname>Ulsoy</surname><given-names>A. Galip</given-names></name>
        </person-group>
        <article-title>On Measures of Coupling Between the Artifact and Controller Optimal Design Problems</article-title>
        <source>International design engineering technical conferences and computers and information in engineering conference</source>
        <year iso-8601-date="2009-08">2009</year><month>08</month>
        <pub-id pub-id-type="doi">10.1115/DETC2009-86868</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-hwang2018b">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Hwang</surname><given-names>John T.</given-names></name>
          <name><surname>Martins</surname><given-names>Joaquim R. R. A.</given-names></name>
        </person-group>
        <article-title>A computational architecture for coupling heterogeneous numerical models and computing coupled derivatives</article-title>
        <source>ACM Transactions on Mathematical Software</source>
        <year iso-8601-date="2018">2018</year>
        <volume>44</volume>
        <issue>4</issue>
        <pub-id pub-id-type="doi">10.1145/3182393</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</ref-list>
</back>
</article>
