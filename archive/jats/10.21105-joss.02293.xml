<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">2293</article-id>
<article-id pub-id-type="doi">10.21105/joss.02293</article-id>
<title-group>
<article-title>StoSpa2: A C++ software package for stochastic
simulations of spatially extended systems</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">0000-0002-0495-9150</contrib-id>
<string-name>Bartosz J. Bartmanski</string-name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author">
<string-name>Ruth E. Baker</string-name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>Mathematical Institute, University of Oxford, Woodstock
Road, Oxford, OX2 6GG, UK</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2020-03-12">
<day>12</day>
<month>3</month>
<year>2020</year>
</pub-date>
<volume>5</volume>
<issue>50</issue>
<fpage>2293</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2021</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Stochastic simulations</kwd>
<kwd>Chemical master equation</kwd>
<kwd>Reaction-diffusion master equation</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Mathematical modelling of complex biological phenomena allows us to
  understand the contributions of different processes to observed
  behaviours. Many of these phenomena involve the reaction and diffusion
  of molecules and so we use so-called reaction-diffusion models to
  describe them mathematically. Reaction-diffusion models are often
  subdivided into three types
  (<xref alt="Hellander &amp; Petzold, 2017" rid="ref-Hellander2017" ref-type="bibr">Hellander
  &amp; Petzold, 2017</xref>): macroscopic, mesoscopic and microscopic.
  Models that describe a system in terms of concentrations are termed
  macroscopic models. At the other end of the spectrum we have
  microscopic models that describe a system by specifying the positions
  (and often velocities) of each molecule. The middle ground between
  these two scales is covered by mesoscopic models, in which
  stochasticity and some individual-level details are included without
  directly tracking the position of every single molecule. Macroscale
  models ignore crucial details such as stochastic effects, while
  microscale models tend to be computationally intensive
  (<xref alt="Osborne et al., 2017" rid="ref-Osborne2017" ref-type="bibr">Osborne
  et al., 2017</xref>;
  <xref alt="Van Liedekerke et al., 2015" rid="ref-VanLiedekerke2015" ref-type="bibr">Van
  Liedekerke et al., 2015</xref>). Mesoscale models offer a good balance
  in that they include stochastic effects without incurring enormous
  computational overheads. The frameworks of the chemical master
  equation (CME) and its spatial extension, the reaction-diffusion
  master equation (RDME)
  (<xref alt="Isaacson, 2009" rid="ref-Isaacson2009" ref-type="bibr">Isaacson,
  2009</xref>,
  <xref alt="2013" rid="ref-Isaacson2013" ref-type="bibr">2013</xref>;
  <xref alt="Van Kampen, 1992" rid="ref-vanKampen2007" ref-type="bibr">Van
  Kampen, 1992</xref>), provide mesoscopic models of reaction and
  diffusion. However, in the majority of these cases, models built in
  the CME/RDME framework are analytically intractable and so model
  behaviours must be explored using stochastic simulation
  algorithms.</p>
  <p><monospace>StoSpa2</monospace> is a C++ software package for
  stochastic simulation of models constructed using the CME and RDME
  frameworks. This software package allows for efficient simulations
  with a user friendly interface, and it includes functionality for
  simulations on both static and growing domains, and time-varying
  reaction rates.</p>
  <p>The primary audience of <monospace>StoSpa2</monospace> are
  researchers who wish to model a chemical or biological system using
  the CME or RDME frameworks.</p>
</sec>
<sec id="the-software">
  <title>The software</title>
  <p><monospace>StoSpa2</monospace> allows for a wide range of
  stochastic simulations within the CME and the RDME frameworks. Within
  the RDME framework, the simulations are independent of the mesh type,
  hence, the simulations can be run on both structured and unstructured
  meshes. Examples of both structured and unstructured meshes can be
  seen in <xref alt="Figure 1" rid="figU003Ameshes">Figure 1</xref>.
  Furthermore, <monospace>StoSpa2</monospace> allows for simulations on
  a uniformly growing domain, by using the Extrande method
  (<xref alt="Voliotis et al., 2016" rid="ref-Voliotis2016" ref-type="bibr">Voliotis
  et al., 2016</xref>).</p>
  <fig>
    <caption><p>Examples of meshes that can be used within
    <monospace>StoSpa2</monospace> for RDME simulations. On the
    left-hand side is an example of an unstructured mesh, while on the
    right-hand side is an example of a structured mesh.
    <styled-content id="figU003Ameshes"></styled-content></p></caption>
    <graphic mimetype="image" mime-subtype="png" xlink:href="figs/meshes.png" xlink:title="" />
  </fig>
  <p>The core of the package is written in the C++ programming language
  to make simulations as efficient as possible. The number of packages
  need to use <monospace>StoSpa2</monospace> has been intentionally kept
  as small as possible to make sure that the software can be used in any
  computing environment that can compile C++ code.</p>
  <p>To make the software user-friendly, the application programming
  interface (API) has been designed with simplicity in mind. All the
  details about the API can be found at <monospace>StoSpa2</monospace>
  documentation website (https://stospa2.readthedocs.io). Furthermore,
  we have included Python bindings, which allow simulations to be run
  from within the Python programming language.
  <monospace>Pybind11</monospace> (https://github.com/pybind/pybind11)
  is used to create <monospace>pystospa</monospace>, the Python binding
  of <monospace>StoSpa2</monospace>. Having a Python interface for a
  software package saves the user from having to recompile code
  themselves for every simulation, making <monospace>StoSpa2</monospace>
  easier to use.</p>
  <p>The continuous integration platform TravisCI
  (https://travis-ci.org/) is used to make sure that any changes in the
  code-base do not break any functionality of
  <monospace>StoSpa2</monospace>. Both the installation and the
  functionality are tested on Linux and OSX operating systems.</p>
</sec>
<sec id="status-of-the-field">
  <title>Status of the field</title>
  <p>The CME and RDME frameworks are used to model various phenomena in
  fields such as chemistry, epidemiology and systems biology. The goal
  behind making <monospace>StoSpa2</monospace> is to facilitate easy and
  fast simulations of systems modelled using the CME and RDME. There are
  some alternative software packages that can be used, for example,
  URDME
  (<xref alt="Drawert et al., 2012" rid="ref-drawert2012urdme" ref-type="bibr">Drawert
  et al., 2012</xref>) and MesoRD
  (<xref alt="Fange et al., 2012" rid="ref-fange2012mesord" ref-type="bibr">Fange
  et al., 2012</xref>), however these both have dependencies that can be
  a barrier to installation and use; URDME has proprietary software as
  dependencies, while MesoRD has a large number of dependencies that
  make it challenging to install. StochSS
  (<xref alt="Drawert et al., 2016" rid="ref-drawert2016stochastic" ref-type="bibr">Drawert
  et al., 2016</xref>) is another software package, and provides a
  docker container and a web interface. However, docker containers
  require special privileges to run, which not every user may have, and
  the web interface does not allow high throughput execution of
  simulations. Hence, we developed <monospace>StoSpa2</monospace>, which
  relies upon as few dependencies as possible and is designed to be
  easily installed. Furthermore, our software can simulate dynamics on a
  uniformly growing domain using the Extrande method
  (<xref alt="Voliotis et al., 2016" rid="ref-Voliotis2016" ref-type="bibr">Voliotis
  et al., 2016</xref>), while the alternatives cannot.</p>
</sec>
<sec id="installation">
  <title>Installation</title>
  <p>The code for <monospace>StoSpa2</monospace> is hosted on GitHub
  (https://github.com/BartoszBartmanski/StoSpa2) with installation
  instructions contained in the <monospace>README.md</monospace> file.
  The first way of installing <monospace>StoSpa2</monospace> involves
  downloading the source code from the GitHub repository and compiling
  the C++ code according to the instructions in the
  <monospace>README.md</monospace> file. However, an easier alternative
  is to use the Python package manager, pip, to download the Python
  binding of <monospace>StoSpa2</monospace>,
  <monospace>pystospa</monospace>, from
  https://pypi.org/project/pystospa/ and install it appropriately. All
  details of the installation, as well as more information, are
  contained in the documentation website
  (https://stospa2.readthedocs.io/en/latest/).</p>
</sec>
<sec id="examples">
  <title>Examples</title>
  <p>In the following examples, we refer as voxels to the sub-intervals
  of a domain of the system to be modelled, while with a mesh we refer
  to how the voxels are organised in space in relation to each
  other.</p>
  <sec id="chemical-master-equation-example">
    <title>Chemical master equation example</title>
    <p>As first example, let us consider the following chemical reaction
    <disp-formula><alternatives>
    <tex-math><![CDATA[
        A \xrightarrow{k} \emptyset \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>A</mml:mi><mml:mover><mml:mo>→</mml:mo><mml:mi>k</mml:mi></mml:mover><mml:mi>∅</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    which occurs at some rate <inline-formula><alternatives>
    <tex-math><![CDATA[k \, s^{-1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>k</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
    on a domain <inline-formula><alternatives>
    <tex-math><![CDATA[\Omega = [0 \,cm, 1 \,cm]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    We can simulate this chemical system with the following code</p>
    <code language="c++">#include &quot;simulator.hpp&quot;

int main() {
    //// Create voxel object. ////
    // number of molecules of species A
    std::vector&lt;unsigned&gt; initial_num = {100};  
    // size of the domain in cm
    double domain_size = 10.0;
    // Arguments: vector of number of molecules, size of the voxel
    StoSpa2::Voxel v(initial_num, domain_size);

    //// Create reaction object. ////
    double k = 1.0;
    auto propensity = [](
        const std::vector&lt;unsigned&gt;&amp; num_mols,
        const double&amp; area)
        { return num_mols[0]; };
    std::vector&lt;int&gt; stoch = {-1};
    // Arguments: reaction rate, propensity func, stoichiometry vector
    StoSpa2::Reaction r(k, propensity, stoch);

    // Add a reaction to a voxel
    v.add_reaction(r);

    // Pass the voxel with the reaction(s) to the simulator object
    StoSpa2::Simulator s({v});

    // Run the simulation.
    // Arguments: path to output file, time step, number of steps
    s.run(&quot;cme_example.dat&quot;, 0.01, 500);
}</code>
    <p>The first line of code in the above example makes sure that we
    can use the <monospace>StoSpa2</monospace> classes. In the main
    function we first define the <monospace>Voxel</monospace> object
    that will represent the domain of the system:</p>
    <code language="c++">std::vector&lt;unsigned&gt; initial_num = {100};
double domain_size = 10.0;
StoSpa2::Voxel v(initial_num, domain_size);</code>
    <p>where we place <inline-formula><alternatives>
    <tex-math><![CDATA[100]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>100</mml:mn></mml:math></alternatives></inline-formula>
    molecules of species <inline-formula><alternatives>
    <tex-math><![CDATA[A]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>A</mml:mi></mml:math></alternatives></inline-formula>
    into a domain of size <inline-formula><alternatives>
    <tex-math><![CDATA[1.0 \, cm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1.0</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    (which in our case is a single voxel of size
    <inline-formula><alternatives>
    <tex-math><![CDATA[1.0 \, cm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1.0</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>).</p>
    <p>In the next segment of the code we create the lambda function
    that represents the propensity function and the
    <monospace>Reaction</monospace> object with a rate of
    <inline-formula><alternatives>
    <tex-math><![CDATA[k = 1.0 \, s^{-1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
    the propensity function <monospace>propensity</monospace> and the
    stoichiometry vector which decreases the number of molecules by one
    any time that the decay reaction happens:</p>
    <code language="c++">double k = 1.0;
auto propensity = [](
    const std::vector&lt;unsigned&gt;&amp; num_mols,
    const double&amp; area)
    { return num_mols[0]; };
std::vector&lt;int&gt; stoch = {-1};
StoSpa2::Reaction r(k, propensity, {-1});</code>
    <p>Though, the reaction propensity function in this case would be
    <inline-formula><alternatives>
    <tex-math><![CDATA[k a]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>k</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    with <inline-formula><alternatives>
    <tex-math><![CDATA[a]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>
    being the number of molecules of A, whereas the above lambda
    function returns just the number of molecules. This interface was
    chosen as to not repeat a lambda function definition if similar
    reactions appear more than once, for example if the reaction happens
    in multiple voxels. The lambda functions for the reaction
    propensities have to take two arguments: a vector and a double. The
    vector represents the number of molecules and the double
    representing the area of a voxel. We then pass the
    <monospace>Reaction</monospace> object to the
    <monospace>Voxel</monospace>:</p>
    <code language="c++">v.add_reaction(r);</code>
    <p>Finally, we run the simulation, which saves the output into
    <monospace>example.dat</monospace> file every
    <inline-formula><alternatives>
    <tex-math><![CDATA[0.01 \, s]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>0.01</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>s</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    for <inline-formula><alternatives>
    <tex-math><![CDATA[500]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>500</mml:mn></mml:math></alternatives></inline-formula>
    steps.</p>
    <code language="c++">StoSpa2::Simulator sim({v});
sim.run(&quot;cme_example.dat&quot;, 0.01, 500);</code>
    <p>We can see example output of a simulation in
    <xref alt="Figure 2" rid="figU003Acme_example">Figure 2</xref>.</p>
    <p>The Python binding of <monospace>StoSpa2</monospace>, called
    <monospace>pystospa</monospace>, allows us to run the same
    simulation using the Python programming language. The Python code in
    this case is as follows:</p>
    <code language="python">import pystospa as ss

# Create voxel object.
# Arguments: vector of number of molecules, size of the voxel
initial_num = [100]  # number of molecules of species A
domain_size = 10.0  # size of the domain in cm
v = ss.Voxel(initial_num, domain_size)

# Create reaction object.
# Arguments: reaction rate, propensity func, stoichiometry vector
k = 1.0
propensity = lambda num_mols, area : num_mols[0]
stoch = [-1]
r = ss.Reaction(k, propensity, stoch)

# Add a reaction to a voxel
v.add_reaction(r)

# Pass the voxel with the reaction(s) to the simulator object
s = ss.Simulator([v])
# Run the simulation.
# Arguments: path to output file, time step, number of steps
s.run(&quot;cme_example.dat&quot;, 0.01, 500)</code>
    <p>which has a very similar interface as the C++ code, but has the
    benefit of not needing any compilation once
    <monospace>pystospa</monospace> is installed.</p>
    <fig>
      <caption><p>Example of a simulation output for a system modelled
      using CME framework. A single species of molecules decays at rate
      <inline-formula><alternatives>
      <tex-math><![CDATA[k \, s^{-1}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>k</mml:mi><mml:mspace width="0.167em"></mml:mspace><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.
      <styled-content id="figU003Acme_example"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="figs/cme_example.png" xlink:title="" />
    </fig>
  </sec>
  <sec id="reaction-diffusion-master-equation-example">
    <title>Reaction-diffusion master equation example</title>
    <p>To demonstrate how StoSpa2 can be used to run simulations within
    the RDME framework an example of a one-dimensional domain
    <inline-formula><alternatives>
    <tex-math><![CDATA[[0 \, cm, 10 \,cm]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    discretised into <inline-formula><alternatives>
    <tex-math><![CDATA[10]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>10</mml:mn></mml:math></alternatives></inline-formula>
    voxels of equal size <inline-formula><alternatives>
    <tex-math><![CDATA[1 \, cm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    is used. Within RDME framework, diffusion is modelled as a jump
    process, and so can be described as a series of reactions as shown
    below <disp-formula><alternatives>
    <tex-math><![CDATA[
        A_1 \stackrel{d}{\rightleftharpoons} A_2 \stackrel{d}{\rightleftharpoons} A_3 \stackrel{d}{\rightleftharpoons} ... \stackrel{d}{\rightleftharpoons} A_{10} \, ,
    ]]></tex-math>
    <mml:math display="block" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mover><mml:mo>⇌</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:msub><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mover><mml:mo>⇌</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:msub><mml:mi>A</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mover><mml:mo>⇌</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mover><mml:mo>⇌</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:msub><mml:mi>A</mml:mi><mml:mn>10</mml:mn></mml:msub><mml:mspace width="0.167em"></mml:mspace><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[A_i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is the the number of molecules of A in voxel
    <inline-formula><alternatives>
    <tex-math><![CDATA[i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>.
    The propensity functions for the above diffusion reactions have the
    following form <inline-formula><alternatives>
    <tex-math><![CDATA[d a_{i}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
    for a molecule of A to jump from voxel
    <inline-formula><alternatives>
    <tex-math><![CDATA[i]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
    to either of the neighbouring ones. The C++ code for such a system
    is as follows:</p>
    <code language="c++">#include &quot;simulator.hpp&quot;

using namespace StoSpa2;

int main() {

    // Create a vector of voxel objects.
    // Arguments: vector of number of molecules, size of the voxel
    std::vector&lt;unsigned&gt; initial_num = {10000};
    double voxel_size = 1.0;
    // First create nine empty voxels
    std::vector&lt;Voxel&gt; vs = std::vector&lt;Voxel&gt;(9, Voxel({0}, voxel_size));
    // Then add the non-empty voxel at the beginning
    vs.insert(vs.begin(), Voxel(initial_num, voxel_size));

    double d = 1.0;  // diffusion rate
    auto propensity = [](
        const std::vector&lt;unsigned&gt;&amp; num_mols,
        const double&amp; area)
    { return num_mols[0]; };
    std::vector&lt;int&gt; stoch = {-1};
    // Create and add the reaction objects
    for (unsigned i=0; i&lt;vs.size()-1; i++) {
        // Add diffusion jump to the right from voxel i to voxel i+1
        vs[i].add_reaction(Reaction(d, propensity, stoch, i+1));
        // Add diffusion jump to the left from voxel i+1 to voxel i
        vs[i+1].add_reaction(Reaction(d, propensity, stoch, i));
    }

    // Pass the voxels with the reaction(s) to the simulator object
    Simulator s(vs);

    // Run the simulation.
    // Arguments: path to output file, time step, number of steps
    s.run(&quot;rdme_example.dat&quot;, 0.01, 500);
}</code>
    <p>which is included in the <monospace>examples</monospace>
    directory of StoSpa2.</p>
    <p>The code is somewhat similar to the chemical master equation
    example, except we have more <monospace>Voxel</monospace> objects.
    We also include the extra line
    <monospace>using namespace StoSpa2</monospace> to save us having to
    write <monospace>StoSpa2::</monospace> in front of every
    <monospace>StoSpa2</monospace> class.</p>
    <p>We start by initialising the <monospace>Voxel</monospace> objects
    that make up the domain of the system. First, we set the variables
    that define the number of molecules in the left-most voxel and the
    size of every voxel. Then, we initialise a vector of nine
    <monospace>Voxel</monospace> objects that contain no molecules and
    we slot an additional <monospace>Voxel</monospace> object at the
    beginning of this vector with <inline-formula><alternatives>
    <tex-math><![CDATA[10000]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>10000</mml:mn></mml:math></alternatives></inline-formula>
    molecules:</p>
    <code language="c++">std::vector&lt;unsigned&gt; initial_num = {10000};
double voxel_size = 1.0;
// First create nine empty voxels
std::vector&lt;Voxel&gt; vs = std::vector&lt;Voxel&gt;(9, Voxel({0}, voxel_size));
// Then add the non-empty voxel at the beginning
vs.insert(vs.begin(), Voxel(initial_num, voxel_size));</code>
    <p>We add reactions to the voxels, where we assume that the voxels
    are ordered by their position on the <inline-formula><alternatives>
    <tex-math><![CDATA[x]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>x</mml:mi></mml:math></alternatives></inline-formula>-axis.
    When adding the diffusion reactions, we have one additional
    parameter in the <monospace>Reaction</monospace> class constructors,
    namely <monospace>diffusion_idx</monospace>, which is the index of
    the neighbouring voxel in to which a molecule jumps if a diffusion
    reaction happens:</p>
    <code language="c++">double d = 1.0;  // diffusion rate
auto propensity = [](
    const std::vector&lt;unsigned&gt;&amp; num_mols,
    const double&amp; area)
{ return num_mols[0]; };
std::vector&lt;int&gt; stoch = {-1};
// Create and add the reaction objects
for (unsigned i=0; i&lt;vs.size()-1; i++) {
    // Add diffusion jump to the right from voxel i to voxel i+1
    vs[i].add_reaction(Reaction(d, propensity, stoch, i+1));
    // Add diffusion jump to the left from voxel i+1 to voxel i
    vs[i+1].add_reaction(Reaction(d, propensity, stoch, i));
}</code>
    <p>And finally, as in the previous example, we run the simulation
    with the <monospace>Simulator</monospace> class instance by passing
    the vector of <monospace>Voxel</monospace> objects to it and calling
    the <monospace>Simulator</monospace> class run function</p>
    <code language="c++">Simulator s(vs);  
s.run(&quot;rdme_example.dat&quot;, 0.01, 500);</code>
    <p>which takes the path to a file where to save the data, followed
    by the size of the time-step and the number of steps to take to
    finish the simulation. The state of the simulation, initially and at
    the final time point, is shown in
    <xref alt="Figure 3" rid="figU003Ardme_example">Figure 3</xref>
    where the molecules diffuse as expected.</p>
    <fig>
      <caption><p>Example of a simulation output for a system modelled
      using RDME framework. Molecules of a single species jump between
      the voxels at rate <inline-formula><alternatives>
      <tex-math><![CDATA[d = 1.0 cm^2 s^{-1}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mi>c</mml:mi><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
      which compose the whole domain of the system.
      <styled-content id="figU003Ardme_example"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="figs/rdme_example.png" xlink:title="" />
    </fig>
  </sec>
  <sec id="growing-domain">
    <title>Growing domain</title>
    <p><monospace>StoSpa2</monospace> allows for stochastic simulations
    on a uniformly growing domain. The example from the previous section
    can be extended to a simulation on a growing domain, by defining the
    domain of the system using <inline-formula><alternatives>
    <tex-math><![CDATA[\Omega(t) = [0, L(t)]]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>Ω</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    where <inline-formula><alternatives>
    <tex-math><![CDATA[L(t) = L_0 e^{rt} \, cm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>L</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    All the voxels growth deterministically according to
    <inline-formula><alternatives>
    <tex-math><![CDATA[h = L_0 e^{rt} / N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>h</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mi>/</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    where <inline-formula><alternatives>
    <tex-math><![CDATA[N]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>N</mml:mi></mml:math></alternatives></inline-formula>
    is the number of voxels, which doesn’t change over the course of a
    simulation. As in the previous example, we discretise the domain
    <inline-formula><alternatives>
    <tex-math><![CDATA[\Omega]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Ω</mml:mi></mml:math></alternatives></inline-formula>
    into <inline-formula><alternatives>
    <tex-math><![CDATA[10]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mn>10</mml:mn></mml:math></alternatives></inline-formula>
    equally-sized voxels, with <inline-formula><alternatives>
    <tex-math><![CDATA[L_0 = 10 \, cm]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:mi>c</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[r = 0.2 \, s^{-1}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>0.2</mml:mn><mml:mspace width="0.167em"></mml:mspace><mml:msup><mml:mi>s</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>,
    hence the code for such a simulation is as follows</p>
    <code language="c++">#include &quot;simulator.hpp&quot;

using namespace StoSpa2;

int main() {
    // We define a lambda function that represents the domain growth function
    auto growth = [](const double&amp; t) { return exp(0.2 * t); };

    // Create a vector of voxel objects.
    // Arguments: vector of number of molecules, size of the voxel
    std::vector&lt;unsigned&gt; initial_num = {10000};
    double voxel_size = 1.0;
    // First create nine empty voxels
    std::vector&lt;Voxel&gt; vs = std::vector&lt;Voxel&gt;(9, Voxel({0}, voxel_size, growth));
    // Then add the non-empty voxel at the beginning
    vs.insert(vs.begin(), Voxel(initial_num, voxel_size, growth));

    double d = 1.0;  // diffusion rate
    auto propensity = [](
        const std::vector&lt;unsigned&gt;&amp; num_mols,
        const double&amp; area)
    { return num_mols[0]; };
    std::vector&lt;int&gt; stoch = {-1};
    // Create and add the reaction objects
    for (unsigned i=0; i&lt;vs.size()-1; i++) {
        // Add diffusion jump to the right from voxel i to voxel i+1
        vs[i].add_reaction(Reaction(d, propensity, stoch, i+1));
        // Add diffusion jump to the left from voxel i+1 to voxel i
        vs[i+1].add_reaction(Reaction(d, propensity, stoch, i));
    }

    // Pass the voxels with the reaction(s) to the simulator object
    Simulator s(vs);

    // Run the simulation.
    // Arguments: path to output file, time step, number of steps
    s.run(&quot;rdme_example.dat&quot;, 0.01, 500);
}</code>
    <p>where there are very few differences between this case and the
    case in the previous section. The main difference being the addition
    of growth function as a lambda function</p>
    <code language="c++">auto growth = [](const double&amp; t) { return exp(0.2 * t); };</code>
    <p>and initialising the <monospace>Voxel</monospace> objects with
    the growth lambda function as a third argument. The comparison of
    the simulation output between a static domain and a growing one can
    be seen in
    <xref alt="Figure 4" rid="figU003Agrowing">Figure 4</xref>, where
    the molecules have diffused to a space more than twice the size of
    the initial domain by the end of the simulation.</p>
    <fig>
      <caption><p>Comparison of a simulation on growing domain with a
      static one.
      <styled-content id="figU003Agrowing"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="figs/growing.png" xlink:title="" />
    </fig>
  </sec>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>B.J.B. was supported by the Engineering and Physical Sciences
  Research Council [grant number EP/G03706X/1]; R.E.B. is a Royal
  Society Wolfson Research Merit Award holder, would like to thank the
  Leverhulme Trust for a Research Fellowship.</p>
</sec>
</body>
<back>
<ref-list>
  <ref-list>
    <ref id="ref-drawert2016stochastic">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Drawert</surname><given-names>B.</given-names></name>
          <name><surname>Hellander</surname><given-names>A.</given-names></name>
          <name><surname>Bales</surname><given-names>B.</given-names></name>
          <name><surname>Banerjee</surname><given-names>D.</given-names></name>
          <name><surname>Bellesia</surname><given-names>G.</given-names></name>
          <name><surname>Daigle Jr</surname><given-names>B. J.</given-names></name>
          <name><surname>Douglas</surname><given-names>G.</given-names></name>
          <name><surname>Gu</surname><given-names>M.</given-names></name>
          <name><surname>Gupta</surname><suffix>A</suffix></name>
          <name><surname>Hellander</surname><given-names>S.</given-names></name>
          <string-name>others</string-name>
        </person-group>
        <article-title>Stochastic simulation service: Bridging the gap between the computational expert and the biologist</article-title>
        <source>PLoS computational biology</source>
        <publisher-name>Public Library of Science</publisher-name>
        <year iso-8601-date="2016">2016</year>
        <volume>12</volume>
        <issue>12</issue>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1005220</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-drawert2012urdme">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Drawert</surname><given-names>B.</given-names></name>
          <name><surname>Engblom</surname><given-names>S.</given-names></name>
          <name><surname>Hellander</surname><given-names>A.</given-names></name>
        </person-group>
        <article-title>URDME: A modular framework for stochastic simulation of reaction-transport processes in complex geometries</article-title>
        <source>BMC systems biology</source>
        <publisher-name>BioMed Central</publisher-name>
        <year iso-8601-date="2012">2012</year>
        <volume>6</volume>
        <issue>1</issue>
        <pub-id pub-id-type="doi">10.1186/1752-0509-6-76</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-fange2012mesord">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Fange</surname><given-names>D.</given-names></name>
          <name><surname>Mahmutovic</surname><given-names>A.</given-names></name>
          <name><surname>Elf</surname><given-names>J.</given-names></name>
        </person-group>
        <article-title>MesoRD 1.0: Stochastic reaction-diffusion simulations in the microscopic limit</article-title>
        <source>Bioinformatics</source>
        <publisher-name>Oxford University Press</publisher-name>
        <year iso-8601-date="2012">2012</year>
        <volume>28</volume>
        <issue>23</issue>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts584</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Voliotis2016">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Voliotis</surname><given-names>M.</given-names></name>
          <name><surname>Thomas</surname><given-names>P.</given-names></name>
          <name><surname>Grima</surname><given-names>R.</given-names></name>
          <name><surname>Bowsher</surname><given-names>C. G.</given-names></name>
        </person-group>
        <article-title>Stochastic simulation of biomolecular networks in dynamic environments</article-title>
        <source>PLoS Computational Biology</source>
        <publisher-name>Public Library of Science</publisher-name>
        <year iso-8601-date="2016">2016</year>
        <volume>12</volume>
        <issue>6</issue>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1004923</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Hellander2017">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Hellander</surname><given-names>S.</given-names></name>
          <name><surname>Petzold</surname><given-names>L.</given-names></name>
        </person-group>
        <article-title>Reaction rates for reaction-diffusion kinetics on unstructured meshes</article-title>
        <source>The Journal of Chemical Physics</source>
        <publisher-name>AIP Publishing LLC</publisher-name>
        <year iso-8601-date="2017">2017</year>
        <volume>146</volume>
        <issue>6</issue>
        <pub-id pub-id-type="doi">10.1063/1.4975167</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Osborne2017">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Osborne</surname><given-names>J. M.</given-names></name>
          <name><surname>Fletcher</surname><given-names>A. G.</given-names></name>
          <name><surname>Pitt-Francis</surname><given-names>J. M.</given-names></name>
          <name><surname>Maini</surname><given-names>P. K.</given-names></name>
          <name><surname>Gavaghan</surname><given-names>D. J.</given-names></name>
        </person-group>
        <article-title>Comparing individual-based approaches to modelling the self-organization of multicellular tissues</article-title>
        <source>PLOS Computational Biology</source>
        <publisher-name>Public Library of Science</publisher-name>
        <year iso-8601-date="2017-02">2017</year><month>02</month>
        <volume>13</volume>
        <issue>2</issue>
        <uri>https://doi.org/10.1371/journal.pcbi.1005387</uri>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1005387</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-VanLiedekerke2015">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Van Liedekerke</surname><given-names>P.</given-names></name>
          <name><surname>Palm</surname><given-names>M. M.</given-names></name>
          <name><surname>Jagiella</surname><given-names>N.</given-names></name>
          <name><surname>Drasdo</surname><given-names>D.</given-names></name>
        </person-group>
        <article-title>Simulating tissue mechanics with agent-based models: Concepts, perspectives and some novel results</article-title>
        <source>Computational particle mechanics</source>
        <publisher-name>Springer</publisher-name>
        <year iso-8601-date="2015">2015</year>
        <volume>2</volume>
        <issue>4</issue>
        <pub-id pub-id-type="doi">10.1007/s40571-015-0082-3</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Isaacson2009">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Isaacson</surname><given-names>S. A.</given-names></name>
        </person-group>
        <article-title>The reaction-diffusion master equation as an asymptotic approximation of diffusion to a small target</article-title>
        <source>SIAM Journal on Applied Mathematics</source>
        <publisher-name>SIAM</publisher-name>
        <year iso-8601-date="2009">2009</year>
        <volume>70</volume>
        <issue>1</issue>
        <pub-id pub-id-type="doi">10.1137/070705039</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-Isaacson2013">
      <element-citation publication-type="article-journal">
        <person-group person-group-type="author">
          <name><surname>Isaacson</surname><given-names>S. A.</given-names></name>
        </person-group>
        <article-title>A convergent reaction-diffusion master equation</article-title>
        <source>The Journal of Chemical Physics</source>
        <publisher-name>American Institute of Physics</publisher-name>
        <year iso-8601-date="2013">2013</year>
        <volume>139</volume>
        <issue>5</issue>
        <pub-id pub-id-type="doi">10.1063/1.4816377</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-vanKampen2007">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name><surname>Van Kampen</surname><given-names>N. G.</given-names></name>
        </person-group>
        <source>Stochastic processes in physics and chemistry</source>
        <publisher-name>Elsevier</publisher-name>
        <year iso-8601-date="1992">1992</year>
        <volume>1</volume>
      </element-citation>
    </ref>
  </ref-list>
</ref-list>
</back>
</article>
